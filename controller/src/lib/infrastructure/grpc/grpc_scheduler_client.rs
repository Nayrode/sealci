use crate::domain::action::entities::action::{
    ActionRequest as DomainActionRequest, ActionResponse as DomainActionResponse,
    ActionResult as DomainActionResult, ActionStatus as DomainActionStatus,
};
use crate::domain::scheduler::services::scheduler_client::SchedulerClient;
use futures::lock::Mutex;
use futures::{Stream, StreamExt};
use std::error::Error;
use std::pin::Pin;
use std::sync::Arc;
use tonic::transport::Channel;
use tonic::{async_trait, Streaming};
use tracing::error;

use crate::infrastructure::grpc::proto_scheduler::controller_client::ControllerClient;
use crate::infrastructure::grpc::proto_scheduler::{
    ActionRequest as ProtoActionRequest, ActionResponse as ProtoActionResponse,
    ActionResult as ProtoActionResult, ExecutionContext, RunnerType,
};

impl From<ProtoActionResponse> for DomainActionResponse {
    fn from(grpc_response: ProtoActionResponse) -> Self {
        DomainActionResponse {
            action_id: grpc_response.action_id,
            log: grpc_response.log,
            result: grpc_response
                .result
                .map(|res| DomainActionResult::from(res)),
        }
    }
}

impl From<ProtoActionResult> for DomainActionResult {
    fn from(grpc_result: ProtoActionResult) -> Self {
        DomainActionResult {
            completion: DomainActionStatus::from_i32(grpc_result.completion),
            exit_code: grpc_result.exit_code,
        }
    }
}

impl DomainActionStatus {
    pub fn from_i32(value: i32) -> DomainActionStatus {
        match value {
            0 => DomainActionStatus::Pending,
            1 => DomainActionStatus::Scheduled,
            2 => DomainActionStatus::Running,  
            3 => DomainActionStatus::Completed,
            4 => DomainActionStatus::Error,     
            _ => DomainActionStatus::Error,
        }
    }
}

impl From<DomainActionRequest> for ProtoActionRequest {
    fn from(domain_request: DomainActionRequest) -> Self {
        ProtoActionRequest {
            action_id: domain_request.action_id,
            context: Some(ExecutionContext {
                r#type: RunnerType::Docker as i32,
                container_image: domain_request.context.container_image.clone(),
            }),
            commands: domain_request.commands.clone(),
            repo_url: domain_request.repo_url.clone(),
        }
    }
}

pub struct GrpcSchedulerClient {
    client: Arc<Mutex<ControllerClient<Channel>>>,
}

impl GrpcSchedulerClient {
    pub async fn new(grpc_url: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let client = ControllerClient::connect(grpc_url.to_string()).await?;
        tracing::info!("Connected to scheduler at {}", grpc_url);
        Ok(Self {
            client: Arc::new(Mutex::new(client)),
        })
    }
}

#[async_trait]
impl SchedulerClient for GrpcSchedulerClient {
    async fn schedule_action(
        &self,
        request: DomainActionRequest,
    ) -> Result<
        Pin<
            Box<
                dyn Stream<Item = Result<DomainActionResponse, Box<dyn Error + Send + Sync>>>
                    + Send,
            >,
        >,
        Box<dyn Error + Send + Sync>,
    > {
        // Convert the domain request to the gRPC request format
        let grpc_request: ProtoActionRequest = request.into();

        // Acquire the controller client lock to ensure thread safety
        // The controller client is our gRPC client that communicates with the scheduler gRPC server, it is generated by tonic
        let mut client = self.client.lock().await;

        // Send the action request to the scheduler
        let response = client.schedule_action(grpc_request).await;

        // Check if the response is successful and get the streaming response
        let mut grpc_stream: Streaming<ProtoActionResponse> = match response {
            Ok(resp) => resp.into_inner(),
            Err(e) => {
                error!("Error while sending action to scheduler: {:?}", e);
                return Err(Box::new(e) as Box<dyn Error + Send + Sync>);
            }
        };

        // Create a stream that processes the gRPC responses
        let stream = async_stream::stream! {
            while let Some(result) = grpc_stream.next().await {
                match result {
                    Ok(grpc_response) => {
                        // Convert the gRPC response to the domain response format
                        yield Ok(DomainActionResponse::from(grpc_response));
                    }
                    Err(e) => {
                        error!("Error while receiving message from scheduler: {:?}", e);
                        yield Err(Box::new(e) as Box<dyn Error + Send + Sync>);
                    }
                }
            }
        };

        Ok(Box::pin(stream))
    }
}
